////////////////////////////////////////////////////////////
// FILE: CGRect+CropHelpers.swift
////////////////////////////////////////////////////////////



//
//  CGRect+CropHelpers.swift
//  CheaterBuster
//

import CoreGraphics

extension CGRect {
    func clamped(to bounds: CGRect, minSide: CGFloat) -> CGRect {
        var r = self
        r.size.width = max(r.size.width, minSide)
        r.size.height = max(r.size.height, minSide)
        if r.width > bounds.width { r.size.width = bounds.width }
        if r.height > bounds.height { r.size.height = bounds.height }
        if r.minX < bounds.minX { r.origin.x = bounds.minX }
        if r.minY < bounds.minY { r.origin.y = bounds.minY }
        if r.maxX > bounds.maxX { r.origin.x = bounds.maxX - r.width }
        if r.maxY > bounds.maxY { r.origin.y = bounds.maxY - r.height }
        return r.integral
    }

    func normalizedPositive() -> CGRect {
        var r = self
        if r.width < 0 { r.origin.x += r.width; r.size.width = abs(r.width) }
        if r.height < 0 { r.origin.y += r.height; r.size.height = abs(r.height) }
        return r
    }

    func fitting(minSide: CGFloat) -> CGRect {
        var r = self
        let w = max(minSide, min(r.width, r.width))
        let h = max(minSide, min(r.height, r.height))
        let cx = r.midX, cy = r.midY
        r.size = CGSize(width: w, height: h)
        r.origin = CGPoint(x: cx - w/2, y: cy - h/2)
        return r.integral
    }
}


////////////////////////////////////////////////////////////
// FILE: CropOverlayHost.swift
////////////////////////////////////////////////////////////

//
//  CropHandle.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 11/2/25.
//


//
//  CropOverlayHost.swift
//  CheaterBuster
//

import SwiftUI

enum CropHandle {
    case none, move, tl, tr, bl, br, top, bottom, left, right
}

struct CropOverlayHost: View {
    @Binding var isCropping: Bool
    @Binding var cropRect: CGRect

    let previewSize: CGSize
    let rotationAngle: Angle
    let userZoom: CGFloat
    let minCropSize: CGFloat
    let cropInset: CGFloat

    let imageVisibleRect: (_ container: CGSize, _ rotatedImageSize: CGSize) -> CGRect
    let rotatedBaseSize: () -> CGSize
    let initialCropRect: (_ container: CGSize, _ image: UIImage, _ rotation: Angle, _ zoom: CGFloat) -> CGRect

    // –°–æ—Å—Ç–æ—è–Ω–∏–µ –∂–µ—Å—Ç–∞
    @State private var activeHandle: CropHandle = .none
    @State private var dragStartRect: CGRect = .zero
    @State private var dragStartPoint: CGPoint = .zero

    // –•–∏—Ç-–∑–æ–Ω—ã (—Å–æ —Å–∫–µ–π–ª–æ–º)
    private let edgeHit: CGFloat = 22.scale
    private let cornerHit: CGFloat = 28.scale

    var body: some View {
        let visibleRect = imageVisibleRect(previewSize, rotatedBaseSize())

        Group {
            if isCropping {
                ZStack {
                    CropOverlayView(cropRect: cropRect, lineWidth: 2.scale)

                    // –ï–¥–∏–Ω—ã–π –ø–µ—Ä–µ—Ö–≤–∞—Ç—á–∏–∫ –∂–µ—Å—Ç–æ–≤ –ø–æ –≤—Å–µ–º—É —Ö–æ–ª—Å—Ç—É
                    Rectangle()
                        .fill(Color.clear)
                        .contentShape(Rectangle())
                        .gesture(globalDrag(in: visibleRect))
                }
                .onAppear {
                    var t = Transaction(); t.disablesAnimations = true
                    withTransaction(t) {
                        cropRect = cropRect.isEmpty
                        ? visibleRect.insetBy(dx: cropInset, dy: cropInset).fitting(minSide: minCropSize)
                        : cropRect.clamped(to: visibleRect, minSide: minCropSize)
                    }
                }
            }
        }
        .animation(.spring(response: 0.25, dampingFraction: 0.9), value: isCropping)
    }

    // MARK: –≤—ã–±–æ—Ä —Ö—ç–Ω–¥–ª–∞
    private func handle(at p: CGPoint, in rect: CGRect) -> CropHandle {
        // –£–≥–ª—ã
        let tl = CGRect(x: rect.minX - cornerHit, y: rect.minY - cornerHit, width: 2 * cornerHit, height: 2 * cornerHit)
        let tr = CGRect(x: rect.maxX - cornerHit, y: rect.minY - cornerHit, width: 2 * cornerHit, height: 2 * cornerHit)
        let bl = CGRect(x: rect.minX - cornerHit, y: rect.maxY - cornerHit, width: 2 * cornerHit, height: 2 * cornerHit)
        let br = CGRect(x: rect.maxX - cornerHit, y: rect.maxY - cornerHit, width: 2 * cornerHit, height: 2 * cornerHit)
        if tl.contains(p) { return .tl }
        if tr.contains(p) { return .tr }
        if bl.contains(p) { return .bl }
        if br.contains(p) { return .br }

        // –†—ë–±—Ä–∞
        let top = CGRect(x: rect.minX + edgeHit, y: rect.minY - edgeHit, width: max(0, rect.width - 2 * edgeHit), height: 2 * edgeHit)
        let bottom = CGRect(x: rect.minX + edgeHit, y: rect.maxY - edgeHit, width: max(0, rect.width - 2 * edgeHit), height: 2 * edgeHit)
        let left = CGRect(x: rect.minX - edgeHit, y: rect.minY + edgeHit, width: 2 * edgeHit, height: max(0, rect.height - 2 * edgeHit))
        let right = CGRect(x: rect.maxX - edgeHit, y: rect.minY + edgeHit, width: 2 * edgeHit, height: max(0, rect.height - 2 * edgeHit))
        if top.contains(p) { return .top }
        if bottom.contains(p) { return .bottom }
        if left.contains(p) { return .left }
        if right.contains(p) { return .right }

        // –í–Ω—É—Ç—Ä–∏ —Ä–∞–º–∫–∏ ‚Äî –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
        if rect.contains(p) { return .move }
        return .none
    }

    // MARK: –µ–¥–∏–Ω—ã–π –∂–µ—Å—Ç
    private func globalDrag(in bounds: CGRect) -> some Gesture {
        DragGesture(minimumDistance: 0)
            .onChanged { value in
                if activeHandle == .none {
                    activeHandle = handle(at: value.startLocation, in: cropRect)
                    dragStartRect = cropRect
                    dragStartPoint = value.startLocation
                }
                guard activeHandle != .none else { return }

                let dx = value.location.x - dragStartPoint.x
                let dy = value.location.y - dragStartPoint.y
                var r = dragStartRect

                switch activeHandle {
                case .move:
                    r.origin.x += dx; r.origin.y += dy
                case .tl:
                    r.origin.x += dx; r.origin.y += dy
                    r.size.width  -= dx; r.size.height -= dy
                case .tr:
                    r.origin.y += dy
                    r.size.width  += dx; r.size.height -= dy
                case .bl:
                    r.origin.x += dx
                    r.size.width  -= dx; r.size.height += dy
                case .br:
                    r.size.width  += dx; r.size.height += dy
                case .top:
                    r.origin.y += dy; r.size.height -= dy
                case .bottom:
                    r.size.height += dy
                case .left:
                    r.origin.x += dx; r.size.width -= dx
                case .right:
                    r.size.width += dx
                case .none:
                    break
                }

                r = r.normalizedPositive().clamped(to: bounds, minSide: minCropSize)

                var t = Transaction(); t.disablesAnimations = true
                withTransaction(t) { cropRect = r }
            }
            .onEnded { _ in activeHandle = .none }
    }
}


////////////////////////////////////////////////////////////
// FILE: CropOverlayView.swift
////////////////////////////////////////////////////////////

//
//  CropOverlayView.swift
//  CheaterBuster
//

import SwiftUI

/// –ó–∞—Ç–µ–º–Ω–µ–Ω–∏–µ + ¬´–¥—ã—Ä–∫–∞¬ª –ø–æ cropRect + —Ä–æ–∑–æ–≤–∞—è —Ä–∞–º–∫–∞ + —É—Ç–æ–ª—â—ë–Ω–Ω—ã–µ —É–≥–æ–ª–∫–∏
struct CropOverlayView: View {
    let cropRect: CGRect
    let lineWidth: CGFloat

    private let cornerLength: CGFloat = 22   // –±–∞–∑–æ–≤–∞—è –¥–ª–∏–Ω–∞ ¬´–Ω–æ–∂–∫–∏¬ª —É–≥–ª–∞ (–¥–æ —Å–∫–µ–π–ª–∞)
    private let cornerThickness: CGFloat = 6 // –±–∞–∑–æ–≤–∞—è —Ç–æ–ª—â–∏–Ω–∞ —É–≥–æ–ª–∫–∞ (–¥–æ —Å–∫–µ–π–ª–∞)

    var body: some View {
        GeometryReader { geo in
            // –õ–æ–∫–∞–ª—å–Ω—ã–µ —Å–∫–µ–π–ª–µ–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã
            let L = cornerLength.scale        // –¥–ª–∏–Ω–∞ ¬´–Ω–æ–∂–∫–∏¬ª —É–≥–æ–ª–∫–∞
            let t = cornerThickness.scale     // —Ç–æ–ª—â–∏–Ω–∞ —É–≥–æ–ª–∫–∞
            let lw = lineWidth.scale          // —Ç–æ–ª—â–∏–Ω–∞ –æ—Å–Ω–æ–≤–Ω–æ–π —Ä–∞–º–∫–∏

            ZStack {
                // –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ + –≤—ã—Ä–µ–∑
                Path { path in
                    path.addRect(CGRect(origin: .zero, size: geo.size))
                    path.addRect(cropRect)
                }
                .fill(Color.black.opacity(0.5), style: FillStyle(eoFill: true))

                // –æ—Å–Ω–æ–≤–Ω–∞—è —Ä–∞–º–∫–∞
                RoundedRectangle(cornerRadius: 0)
                    .stroke(Tokens.Color.accent, lineWidth: lw)
                    .frame(width: cropRect.width, height: cropRect.height)
                    .position(x: cropRect.midX, y: cropRect.midY)

                // —É–≥–æ–ª–∫–∏
                corner(.topLeft,     L: L, t: t)
                corner(.topRight,    L: L, t: t)
                corner(.bottomLeft,  L: L, t: t)
                corner(.bottomRight, L: L, t: t)
            }
        }
        .allowsHitTesting(false)
    }

    private enum Corner { case topLeft, topRight, bottomLeft, bottomRight }

    @ViewBuilder
    private func corner(_ c: Corner, L: CGFloat, t: CGFloat) -> some View {
        let w = cropRect.width, h = cropRect.height
        let x = cropRect.minX,  y = cropRect.minY

        switch c {
        case .topLeft:
            Group {
                RoundedRectangle(cornerRadius: (t / 2).scale)
                    .fill(Tokens.Color.accent)
                    .frame(width: L, height: t)
                    .position(x: x + L / 2, y: y + t / 2)
                RoundedRectangle(cornerRadius: (t / 2).scale)
                    .fill(Tokens.Color.accent)
                    .frame(width: t, height: L)
                    .position(x: x + t / 2, y: y + L / 2)
            }
        case .topRight:
            Group {
                RoundedRectangle(cornerRadius: (t / 2).scale)
                    .fill(Tokens.Color.accent)
                    .frame(width: L, height: t)
                    .position(x: x + w - L / 2, y: y + t / 2)
                RoundedRectangle(cornerRadius: (t / 2).scale)
                    .fill(Tokens.Color.accent)
                    .frame(width: t, height: L)
                    .position(x: x + w - t / 2, y: y + L / 2)
            }
        case .bottomLeft:
            Group {
                RoundedRectangle(cornerRadius: (t / 2).scale)
                    .fill(Tokens.Color.accent)
                    .frame(width: L, height: t)
                    .position(x: x + L / 2, y: y + h - t / 2)
                RoundedRectangle(cornerRadius: (t / 2).scale)
                    .fill(Tokens.Color.accent)
                    .frame(width: t, height: L)
                    .position(x: x + t / 2, y: y + h - L / 2)
            }
        case .bottomRight:
            Group {
                RoundedRectangle(cornerRadius: (t / 2).scale)
                    .fill(Tokens.Color.accent)
                    .frame(width: L, height: t)
                    .position(x: x + w - L / 2, y: y + h - t / 2)
                RoundedRectangle(cornerRadius: (t / 2).scale)
                    .fill(Tokens.Color.accent)
                    .frame(width: t, height: L)
                    .position(x: x + w - t / 2, y: y + h - L / 2)
            }
        }
    }
}


////////////////////////////////////////////////////////////
// FILE: FacePreviewCanvas.swift
////////////////////////////////////////////////////////////

//
//  FacePreviewCanvas.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 11/2/25.
//


//
//  FacePreviewCanvas.swift
//  CheaterBuster
//

import SwiftUI

struct FacePreviewCanvas: View {
    let image: UIImage?

    @Binding var rotationAngle: Angle
    @Binding var userZoom: CGFloat
    @Binding var isCropping: Bool
    @Binding var cropRect: CGRect
    @Binding var previewSize: CGSize

    let minCropSize: CGFloat
    let cropInset: CGFloat

    // –ò–Ω—ä–µ–∫—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π –∏–∑ FaceSearchView
    let imageVisibleRect: (_ container: CGSize, _ rotatedImageSize: CGSize) -> CGRect
    let rotatedBaseSize: () -> CGSize
    let initialCropRect: (_ container: CGSize, _ image: UIImage, _ rotation: Angle, _ zoom: CGFloat) -> CGRect

    var body: some View {
        GeometryReader { geo in
            ZStack {
                if let uiImage = image {
                    let baseSize: CGSize = {
                        let deg = abs(Int(rotationAngle.degrees)) % 360
                        let swap = (deg == 90 || deg == 270)
                        return CGSize(width: swap ? uiImage.size.height : uiImage.size.width,
                                      height: swap ? uiImage.size.width  : uiImage.size.height)
                    }()

                    let scale: CGFloat = {
                        let s = min(geo.size.width / baseSize.width, geo.size.height / baseSize.height)
                        return s * userZoom
                    }()

                    Image(uiImage: uiImage)
                        .resizable()
                        .frame(width: uiImage.size.width, height: uiImage.size.height)
                        .rotationEffect(rotationAngle)
                        .scaleEffect(scale)
                        .frame(width: geo.size.width, height: geo.size.height)

                    CropOverlayHost(
                        isCropping: $isCropping,
                        cropRect: $cropRect,
                        previewSize: geo.size,
                        rotationAngle: rotationAngle,
                        userZoom: userZoom,
                        minCropSize: minCropSize,
                        cropInset: cropInset,
                        imageVisibleRect: imageVisibleRect,
                        rotatedBaseSize: rotatedBaseSize,
                        initialCropRect: initialCropRect
                    )
                } else {
                    ContentUnavailableView(
                        "Select a photo",
                        systemImage: "photo",
                        description: Text("Pick one image to search by face.")
                    )
                }
            }
            .onAppear { previewSize = geo.size }
            .onChange(of: geo.size) { _, new in previewSize = new }
        }
    }
}


////////////////////////////////////////////////////////////
// FILE: FaceSearchComponents.swift
////////////////////////////////////////////////////////////

//
//  HeaderBar.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 11/2/25.
//


import SwiftUI

struct HeaderBar: View {
    let title: String
    let onBack: () -> Void
    var body: some View {
        HStack {
            BackButton(size: 44.scale) { onBack() }
            Spacer()
            Text(title)
                .font(Tokens.Font.bodyMedium18)
                .foregroundStyle(Color(hex: "#141414"))
            Spacer()
            Color.clear.frame(width: 44.scale, height: 44.scale)
        }
        .padding(.horizontal, 16.scale)
        .padding(.top, 16.scale)
    }
}

struct ControlButton: View {
    let asset: String
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            ZStack {
                RoundedRectangle(cornerRadius: 22.scale, style: .continuous)
                    .fill(Color.white)
                    .frame(width: 48.scale, height: 48.scale)
                    .shadow(color: Color.black.opacity(0.06), radius: 6.scale)

                Image(asset)
                    .resizable()
                    .renderingMode(.template)
                    .scaledToFit()
                    .frame(width: 20.scale, height: 20.scale)
                    .foregroundStyle(Color(hex: "#141414"))
            }
        }
        .buttonStyle(.plain)
        .contentShape(RoundedRectangle(cornerRadius: 22.scale, style: .continuous))
    }
}

struct NextButton: View {
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            ZStack {
                Circle()
                    .fill(Tokens.Color.accent)
                    .frame(width: 48.scale, height: 48.scale)
                    .shadow(color: Tokens.Color.shadowBlack7, radius: 12.scale)
                    .shadow(color: Tokens.Color.shadowBlack7.opacity(0.6), radius: 4.scale)

                Image("nextArrow")
                    .resizable()
                    .renderingMode(.template)
                    .scaledToFit()
                    .frame(width: 20.scale, height: 20.scale)
                    .foregroundStyle(.white)
            }
        }
        .buttonStyle(.plain)
        .contentShape(Circle())
    }
}


////////////////////////////////////////////////////////////
// FILE: FaceSearchView.swift
////////////////////////////////////////////////////////////

//  FaceSearchView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 11/01/25.
//

import SwiftUI
import PhotosUI
import Swinject
import UIKit

struct FaceSearchView: View {

    // MARK: - Local types

    enum SearchTarget {
        case woman
        case man

        var title: String {
            switch self {
            case .woman: return "Woman"
            case .man:   return "Man"
            }
        }
    }

    // MARK: - Deps

    @ObservedObject var vm: SearchViewModel
    @Environment(\.dismiss) private var dismiss
    @Environment(\.resolver) private var resolver

    /// –§–æ—Ç–æ, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–∏—à–ª–æ –∏–∑ SearchScreen (Upload Photo).
    @Environment(\.selectedFaceImage) private var initialImage: UIImage?

    // MARK: - Photo picker

    @State private var item: PhotosPickerItem?
    @State private var image: UIImage?

    // –ü–∏–∫–µ—Ä –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –Ω–µ—Ç initialImage
    @State private var showPhotoPicker: Bool = false
    @State private var didSelectPhoto: Bool = false

    // MARK: - Rotation / zoom

    @State private var rotationAngle: Angle = .zero
    @State private var userZoom: CGFloat = 1.0

    // MARK: - LoadingView navigation

    @State private var showLoading: Bool = false
    @State private var loadingPreview: UIImage? = nil

    /// JPEG-–¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –ø–µ—Ä–µ–¥–∞—ë–º –≤ LoadingView,
    /// —á—Ç–æ–±—ã –æ–Ω —É–∂–µ —Å–∞–º —Ä–µ—à–∏–ª, –∫–æ–≥–¥–∞ –¥–µ—Ä–Ω—É—Ç—å runImageSearch.
    @State private var loadingJPEG: Data? = nil

    let onFinished: () -> Void  // –∏–∑ SearchScreen: path.append(.results)

    // MARK: - Crop state

    @State private var isCropping: Bool = false
    @State private var cropRect: CGRect = .zero
    @State private var previewSize: CGSize = .zero

    private let minCropSize: CGFloat = 120
    private let cropInset: CGFloat = 16

    private var minCropSizeScaled: CGFloat { minCropSize.scale }
    private var cropInsetScaled: CGFloat { cropInset.scale }

    // MARK: - Gender selection

    @State private var selectedTarget: SearchTarget = .man

    // MARK: - Init

    init(vm: SearchViewModel, onFinished: @escaping () -> Void) {
        self.vm = vm
        self.onFinished = onFinished
    }

    // MARK: - Body

    var body: some View {
        // ==== safeArea + —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ —á–µ—Ä–µ–∑ DeviceLayout ====
        let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene
        let window = windowScene?.windows.first(where: { $0.isKeyWindow })

        let topInset = window?.safeAreaInsets.top ?? 0

        let baseTopPadding: CGFloat = 20.scale

        // üîù –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –≤–µ—Ä—Ö–Ω–∏–π –æ—Ç—Å—Ç—É–ø
        let safeTopPadding: CGFloat = {
            switch DeviceLayout.type {
            case .smallStatusBar:
                return 90.scale
            case .notch, .dynamicIsland:
                return max(topInset, 60.scale)
            case .unknown:
                return max(topInset, 20.scale)
            }
        }()

        let imageHeight: CGFloat = {
            switch DeviceLayout.type {
            case .smallStatusBar:
                return 300.scale
            case .notch, .dynamicIsland:
                return 430.scale
            case .unknown:
                return 430.scale
            }
        }()

        return ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(spacing: 0) {
                HeaderBar(title: "Search by photo") { dismiss() }
                    
                

                // MARK: - Question + gender selector
                VStack(alignment: .leading, spacing: 16.scale) {
                    Text("Who are you searching for?")
                        .font(Tokens.Font.medium20)
                        .foregroundStyle(Tokens.Color.textPrimary)

                    genderSelector
                }
                .padding(.horizontal, 24.scale)
                .padding(.top,  12.scale)
                .padding(.bottom, 8.scale)

                // MARK: - Preview
                FacePreviewCanvas(
                    image: image,
                    rotationAngle: $rotationAngle,
                    userZoom: $userZoom,
                    isCropping: $isCropping,
                    cropRect: $cropRect,
                    previewSize: $previewSize,
                    minCropSize: minCropSizeScaled,
                    cropInset: cropInsetScaled,
                    imageVisibleRect: imageVisibleRect(in:rotatedImageSize:),
                    rotatedBaseSize: rotatedBaseSize,
                    initialCropRect: initialCropRect(for:image:rotation:zoom:)
                )
                .frame(height: imageHeight)
                .frame(maxWidth: .infinity, alignment: .center)
                .padding(.horizontal, 24.scale)
                .padding(.vertical, 8.scale)

                Spacer(minLength: 0)
            }
            .padding(.top, safeTopPadding.scale + (DeviceLayout.isSmallStatusBarPhone ? 0.scale : 24.scale))
        }
        .navigationBarBackButtonHidden(true)
        .buttonStyle(OpacityTapButtonStyle())

        // MARK: - –ù–∏–∂–Ω—è—è –ø–∞–Ω–µ–ª—å (—á–µ—Ä–µ–∑ safeAreaInset)

        .safeAreaInset(edge: .bottom, spacing: 0) {
            VStack(spacing: 32.scale) {

                // —Ç—Ä–∏ –∫–æ–Ω—Ç—Ä–æ–ª-–∫–Ω–æ–ø–∫–∏
                HStack(spacing: 24.scale) {
                    ControlButton(asset: "rotateLeft") {
                        withAnimation { rotationAngle -= .degrees(90) }
                    }

                    ControlButton(asset: "rotateRight") {
                        withAnimation { rotationAngle += .degrees(90) }
                    }

                    ControlButton(asset: "resize") {
                        if isCropping == false {
                            withAnimation(.spring(response: 0.25, dampingFraction: 0.9)) {
                                isCropping = true
                            }
                            if let img = image {
                                var t = Transaction(); t.disablesAnimations = true
                                withTransaction(t) {
                                    cropRect = initialCropRect(
                                        for: previewSize,
                                        image: img,
                                        rotation: rotationAngle,
                                        zoom: userZoom
                                    )
                                }
                            }
                        } else {
                            withAnimation(.spring(response: 0.25, dampingFraction: 0.9)) {
                                isCropping = false
                            }
                        }
                    }
                }

                // –∫–Ω–æ–ø–∫–∞ Start search –≤ —Å—Ç–∏–ª–µ SearchScreen
                FaceStartSearchButton(
                    isEnabled: image != nil,
                    action: {
                        guard let img = image else { return }
                        runSearchPipeline(with: img)
                    }
                )
            }
            .frame(maxWidth: .infinity, alignment: .center)
            .padding(.horizontal, 24.scale)
            .padding(.top, baseTopPadding)
            .padding(.bottom, 110.scale)
            .background(Tokens.Color.surfaceCard)
        }

        // MARK: - Photos picker

        .photosPicker(
            isPresented: $showPhotoPicker,
            selection: $item,
            matching: .images
        )
        .onChange(of: item) { _, newValue in
            didSelectPhoto = newValue != nil

            Task { @MainActor in
                guard let data = try? await newValue?.loadTransferable(type: Data.self),
                      let img = UIImage(data: data) else { return }
                image = img
                rotationAngle = .zero
                userZoom = 1.0
                isCropping = false
            }
        }
        .onChange(of: showPhotoPicker) { wasPresented, isPresented in
            if wasPresented && !isPresented && didSelectPhoto == false && image == nil {
                // —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ—Ç —Ñ–æ—Ç–æ —Å–æ–≤—Å–µ–º ‚Äî —É—Ö–æ–¥–∏–º –Ω–∞–∑–∞–¥
                dismiss()
            }
        }

        // MARK: - –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ LoadingView

        .navigationDestination(isPresented: $showLoading) {
            LoadingView(
                mode: .face,
                previewImage: loadingPreview,
                imageJPEGData: loadingJPEG,
                vm: vm,
                onFinished: {
                    onFinished()
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
                        showLoading = false
                    }
                }
            )
            .navigationBarBackButtonHidden(true)
            .toolbar(.hidden, for: .navigationBar)
            .transaction { t in t.animation = nil }
            .transition(.identity)
        }

        // MARK: - –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è

        .onAppear {
            if image == nil, let initial = initialImage {
                // —Ñ–æ—Ç–æ –ø—Ä–∏—à–ª–æ –∏–∑ SearchScreen
                image = initial
                rotationAngle = .zero
                userZoom = 1.0
                isCropping = false
            } else if image == nil && initialImage == nil {
                // —Å—Ç–∞—Ä—ã–π —Ñ–ª–æ—É ‚Äî –æ—Ç–∫—Ä—ã–≤–∞–µ–º –ø–∏–∫–µ—Ä
                showPhotoPicker = true
            }
        }
    }
}

// MARK: - Gender selector UI

private extension FaceSearchView {

    var genderSelector: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 22.scale, style: .continuous)
                .fill(Color.white)
                .shadow(color: Color.black.opacity(0.06), radius: 6.scale)

            HStack(spacing: 0) {
                genderSegment(.woman)
                genderSegment(.man)
            }
            .padding(4.scale)
        }
        .frame(width: 343.scale, height: 47.scale)
    }

    func genderSegment(_ target: SearchTarget) -> some View {
        let isSelected = (target == selectedTarget)

        return Button {
            withAnimation(.spring(response: 0.25, dampingFraction: 0.9)) {
                selectedTarget = target
            }
        } label: {
            Text(target.title)
                .font(Tokens.Font.bodySemibold16)
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .foregroundStyle(isSelected ? Color.white : Tokens.Color.textPrimary)
                .background(
                    RoundedRectangle(cornerRadius: 22.scale, style: .continuous)
                        .fill(isSelected ? Tokens.Color.accent : Color.white)
                )
        }
        .buttonStyle(.plain)
        .contentShape(RoundedRectangle(cornerRadius: 22.scale, style: .continuous))
    }
}

// MARK: - Start search button (Face)

private struct FaceStartSearchButton: View {
    let isEnabled: Bool
    let action: () -> Void

    var body: some View {
        Button {
            if isEnabled { action() }
        } label: {
            HStack(spacing: 8.scale) {
                Text("Start search")
                    .font(Tokens.Font.bodySemibold16)
                    .tracking(-0.16)

                Spacer()

                Image("nextArrow")
                    .resizable()
                    .renderingMode(.template)
                    .scaledToFit()
                    .frame(width: 20.scale, height: 20.scale)
            }
            .foregroundColor(.white)
            .padding(.leading, 20.scale)
            .padding(.trailing, 24.scale)
            .frame(width: 343.scale, height: 51.scale, alignment: .center)
            .background(
                Tokens.Color.accent.opacity(isEnabled ? 1.0 : 0.5)
            )
            .clipShape(
                RoundedRectangle(
                    cornerRadius: Tokens.Radius.pill,
                    style: .continuous
                )
            )
        }
        .buttonStyle(OpacityTapButtonStyle())
        .frame(maxWidth: .infinity, alignment: .center)
        .disabled(!isEnabled)
    }
}

// MARK: - –ü–æ–∏—Å–∫–æ–≤—ã–π –ø–∞–π–ø–ª–∞–π–Ω

private extension FaceSearchView {
    func runSearchPipeline(with img: UIImage) {
        // 1) –î–µ–ª–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É (–∫—Ä–æ–ø + —Ä–æ—Ç–µ–π—Ç)
        let finalImage: UIImage = ImageCropper.editedImage(
            source: img,
            imageViewSize: previewSize,
            rotation: rotationAngle,
            userZoom: userZoom,
            imageOffset: .zero,
            cropRectInView: cropRect,
            isCropping: isCropping
        ) ?? img

        // 2) –ì–æ—Ç–æ–≤–∏–º –ø—Ä–µ–≤—å—é –∏ JPEG –¥–ª—è LoadingView
        loadingPreview = finalImage
        loadingJPEG = finalImage.jpegData(compressionQuality: 0.85)

        // 3) –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ ‚Äî –∫–∞–∫ –∏ —Ä–∞–Ω—å—à–µ
        Analytics.shared.track("search_face_total")

        switch selectedTarget {
        case .woman:
            Analytics.shared.track("search_face_woman")
        case .man:
            Analytics.shared.track("search_face_man")
        }

        // 4) –ù–ï –≤—ã–∑—ã–≤–∞–µ–º –∑–¥–µ—Å—å runImageSearch.
        //    –†–µ–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å –¥–µ–ª–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ LoadingView, –∫–æ–≥–¥–∞:
        //    - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –ø—Ä–µ–º–∏—É–º, –∏–ª–∏
        //    - –æ–Ω –∫—É–ø–∏–ª –ø—Ä–µ–º–∏—É–º –Ω–∞ Paywall.
        showLoading = true
    }
}

// MARK: - Geometry helpers

private extension FaceSearchView {
    func imageVisibleRect(in container: CGSize, rotatedImageSize: CGSize) -> CGRect {
        let s = min(container.width / rotatedImageSize.width,
                    container.height / rotatedImageSize.height)
        let drawSize = CGSize(width: rotatedImageSize.width * s * userZoom,
                              height: rotatedImageSize.height * s * userZoom)
        let origin = CGPoint(x: (container.width - drawSize.width) / 2.0,
                             y: (container.height - drawSize.height) / 2.0)
        let imgRect = CGRect(origin: origin, size: drawSize)
        return imgRect.intersection(CGRect(origin: .zero, size: container)).integral
    }

    func rotatedBaseSize() -> CGSize {
        guard let img = image else { return .zero }
        let deg = (abs(Int(rotationAngle.degrees)) % 360 + 360) % 360
        let swap = (deg == 90 || deg == 270)
        return CGSize(width: swap ? img.size.height : img.size.width,
                      height: swap ? img.size.width  : img.size.height)
    }

    func initialCropRect(for container: CGSize, image: UIImage, rotation: Angle, zoom: CGFloat) -> CGRect {
        let visible = imageVisibleRect(in: container, rotatedImageSize: rotatedBaseSize())
        var r = visible.insetBy(dx: cropInsetScaled, dy: cropInsetScaled)
        if r.width < minCropSizeScaled || r.height < minCropSizeScaled {
            r = visible.fitting(minSide: minCropSizeScaled)
        }
        return r.integral
    }
}


////////////////////////////////////////////////////////////
// FILE: ImageCropper.swift
////////////////////////////////////////////////////////////

//  ImageCropper.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 11/02/25.
//

import UIKit
import SwiftUI
import CoreGraphics

// MARK: - ImageCropper
/// –ï–¥–∏–Ω—ã–π –∫–æ–Ω–≤–µ–π–µ—Ä ¬´–∫–∞–∫ –≤ –ø—Ä–µ–≤—å—é¬ª:
/// 1) –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏ (EXIF -> .up),
/// 2) –ø–æ–≤–æ—Ä–æ—Ç –Ω–∞ —É–≥–æ–ª –∏–∑ SwiftUI (–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π = –ø–æ —á–∞—Å–æ–≤–æ–π),
/// 3) (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –∫—Ä–æ–ø –ø–æ —Ä–∞–º–∫–µ, –∑–∞–¥–∞–Ω–Ω–æ–π –≤–æ view-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö,
/// 4) –≤—Å–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ CGAffineTransform + inverse ‚Äî –±–µ–∑ —Ö–∞—Ä–¥–∫–æ–¥-–∫–µ–π—Å–æ–≤ 90/180/270.
struct ImageCropper {

    // MARK: - –ü—É–±–ª–∏—á–Ω—ã–π –∫–æ–Ω–≤–µ–π–µ—Ä
    static func editedImage(
        source original: UIImage,
        imageViewSize: CGSize,
        rotation: Angle,
        userZoom: CGFloat,
        imageOffset: CGPoint,
        cropRectInView: CGRect,
        isCropping: Bool
    ) -> UIImage? {

        // 0) –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º EXIF-–æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é ‚Üí –ø–∏–∫—Å–µ–ª–∏ –∫–∞–∫ –Ω–∞ —ç–∫—Ä–∞–Ω–µ, imageOrientation = .up
        let normalized = original.normalizedOrientation()

        // 1) –§–∏–∑–∏—á–µ—Å–∫–∏–π –ø–æ–≤–æ—Ä–æ—Ç bitmap (—É–∂–µ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ).
        // SwiftUI: +angle = –≤–∏–∑—É–∞–ª—å–Ω–æ –ø–æ —á–∞—Å–æ–≤–æ–π. –í CoreGraphics –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —É–≥–æ–ª,
        // —á—Ç–æ–±—ã –≤–∏–∑—É–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ–≤–ø–∞–ª —Å –ø—Ä–µ–≤—å—é.
        let rotated = rotate(source: normalized, rotationCW: rotation) ?? normalized

        // 2) –ö—Ä–æ–ø (–µ—Å–ª–∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω): —É–∂–µ –Ω–∞ –ü–û–í–Å–†–ù–£–¢–û–ú –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏.
        guard isCropping else {
            return rotated
        }

        return cropUsingInvertedTransform(
            source: rotated,
            imageViewSize: imageViewSize,
            rotation: .zero,                 // –ø–æ–≤–æ—Ä–æ—Ç —É–∂–µ ¬´–≤—à–∏—Ç¬ª –≤ rotated
            userZoom: userZoom,
            imageOffset: imageOffset,
            cropRectInView: cropRectInView
        )
    }

    // MARK: - –ü–æ–≤–æ—Ä–æ—Ç
    /// –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç bitmap ¬´–∫–∞–∫ –≤ –ø—Ä–µ–≤—å—é¬ª:
    /// rotationCW ‚Äî SwiftUI —É–≥–æ–ª (–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π = –ø–æ —á–∞—Å–æ–≤–æ–π —Å—Ç—Ä–µ–ª–∫–µ).
    /// –ù–∞ –≤—Ö–æ–¥–µ –æ–∂–∏–¥–∞–µ—Ç—Å—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ c imageOrientation == .up (—Å–º. normalizedOrientation()).
    static func rotate(source original: UIImage, rotationCW: Angle) -> UIImage? {
        guard let cg = original.cgImage else { return nil }

        // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–æ –∫—Ä–∞—Ç–Ω—ã—Ö 90 ‚Äî —É —Ç–µ–±—è –∫–Ω–æ–ø–∫–∏ –ø–æ 90 –≥—Ä–∞–¥—É—Å–æ–≤.
        let degCW = ((Int(round(rotationCW.degrees)) % 360) + 360) % 360

        // –ï—Å–ª–∏ —É–≥–æ–ª 0¬∞ ‚Äî –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
        if degCW == 0 {
            return original
        }

        // CoreGraphics –∏—Å–ø–æ–ª—å–∑—É–µ—Ç ¬´–º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π¬ª –∑–Ω–∞–∫ (–ø–ª—é—Å = –ø—Ä–æ—Ç–∏–≤ —á–∞—Å–æ–≤–æ–π),
        // –ø–æ—ç—Ç–æ–º—É –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞ –ø–æ —á–∞—Å–æ–≤–æ–π –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —É–≥–æ–ª.
        let radians = -CGFloat(Double(degCW) * .pi / 180.0)

        let w = CGFloat(cg.width)
        let h = CGFloat(cg.height)
        let outSize: CGSize =
            (degCW == 90 || degCW == 270)
            ? CGSize(width: h, height: w)
            : CGSize(width: w, height: h)

        let colorSpace = cg.colorSpace ?? CGColorSpaceCreateDeviceRGB()
        guard let ctx = CGContext(
            data: nil,
            width: Int(outSize.width),
            height: Int(outSize.height),
            bitsPerComponent: cg.bitsPerComponent,
            bytesPerRow: 0,
            space: colorSpace,
            bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue
        ) else { return nil }

        // –°—Ç–∞–≤–∏–º —Ü–µ–Ω—Ç—Ä –≤—ã—Ö–æ–¥–Ω–æ–≥–æ –ø–æ–ª–æ—Ç–Ω–∞ –≤ (0,0), –≤—Ä–∞—â–∞–µ–º, –∑–∞—Ç–µ–º —Ä–∏—Å—É–µ–º –∏—Å—Ö–æ–¥–Ω–∏–∫ —Å –ø–µ—Ä–µ–Ω–æ—Å–æ–º –∫ —Ü–µ–Ω—Ç—Ä—É.
        ctx.translateBy(x: outSize.width / 2, y: outSize.height / 2)
        ctx.rotate(by: radians)
        ctx.translateBy(x: -w / 2, y: -h / 2)
        ctx.draw(cg, in: CGRect(x: 0, y: 0, width: w, height: h))

        guard let outImage = ctx.makeImage() else { return nil }
        return UIImage(cgImage: outImage, scale: original.scale, orientation: .up)
    }

    // MARK: - –ö—Ä–æ–ø —á–µ—Ä–µ–∑ –∏–Ω–≤–µ—Ä—Å–∏—é —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞
    /// –°—Ç—Ä–æ–∏–º transform –∏–∑ image-space ‚Üí view-space:
    ///   T = Translate(viewCenter) * Scale(S) * Rotate(radiansUI) * Translate(-imageCenter)
    /// –≥–¥–µ S = min(viewW/rotW, viewH/rotH) * userZoom.
    /// –ó–∞—Ç–µ–º –±–µ—Ä—ë–º T^-1 –∏ –ø—Ä–æ–≥–æ–Ω—è–µ–º —á–µ—Ç—ã—Ä–µ —É–≥–ª–∞ cropRectInView –≤ image-space.
    private static func cropUsingInvertedTransform(
        source original: UIImage,
        imageViewSize: CGSize,
        rotation: Angle,
        userZoom: CGFloat,
        imageOffset: CGPoint,
        cropRectInView: CGRect
    ) -> UIImage? {

        guard let cg = original.cgImage else { return nil }

        let w0 = CGFloat(cg.width)
        let h0 = CGFloat(cg.height)
        let imgCenter = CGPoint(x: w0 / 2, y: h0 / 2)
        let viewCenter = CGPoint(x: imageViewSize.width / 2, y: imageViewSize.height / 2)

        // –î–ª—è rotated (–º—ã —É–∂–µ –ø–µ—Ä–µ–¥–∞—ë–º rotated –∏ rotation = .zero),
        // –Ω–æ –æ—Å—Ç–∞–≤–ª—è—é —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ—Å—Ç—å: —Ä–∞–∑–º–µ—Ä rotated-–ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–æ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è.
        let degCW = ((Int(round(rotation.degrees)) % 360) + 360) % 360
        let swapWH = (degCW == 90 || degCW == 270)
        let rotW = swapWH ? h0 : w0
        let rotH = swapWH ? w0 : h0

        let baseScale = min(imageViewSize.width / max(rotW, 1),
                            imageViewSize.height / max(rotH, 1))
        let S = baseScale * max(userZoom, 0.0001)

        // –í–∏–∑—É–∞–ª—å–Ω–æ –ø–æ —á–∞—Å–æ–≤–æ–π = –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π —É–≥–æ–ª –¥–ª—è CGAffineTransform.
        let radiansUI = -CGFloat(rotation.radians)

        // Image-space -> View-space
        var T = CGAffineTransform.identity
        T = T.translatedBy(x: viewCenter.x, y: viewCenter.y)
        T = T.scaledBy(x: S, y: S)
        T = T.rotated(by: radiansUI)
        T = T.translatedBy(x: -imgCenter.x, y: -imgCenter.y)
        // –°–¥–≤–∏–≥ –ø–∞–ª—å—Ü–µ–º/–ø–∞–Ω–æ—Ä–∞–º–æ–π, –µ—Å–ª–∏ –∫–æ–≥–¥–∞-—Ç–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª–µ–Ω:
        T = T.translatedBy(x: imageOffset.x / max(1, 1), y: imageOffset.y / max(1, 1))

        guard let Tinverse = T.invertedIfPossible else { return nil }

        // –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä—É–µ–º —É–≥–ª—ã cropRect –∏–∑ view-space –≤ image-space
        let p1 = CGPoint(x: cropRectInView.minX, y: cropRectInView.minY).applying(Tinverse)
        let p2 = CGPoint(x: cropRectInView.maxX, y: cropRectInView.minY).applying(Tinverse)
        let p3 = CGPoint(x: cropRectInView.maxX, y: cropRectInView.maxY).applying(Tinverse)
        let p4 = CGPoint(x: cropRectInView.minX, y: cropRectInView.maxY).applying(Tinverse)

        var crop = CGRect.enclosing(points: [p1, p2, p3, p4]).integral

        // –ö–ª–∞–º–ø–∏–º –≤ –≥—Ä–∞–Ω–∏—Ü—ã –±–∏—Ç–º–∞–ø—ã
        let bounds = CGRect(x: 0, y: 0, width: w0, height: h0)
        crop = crop.intersection(bounds)
        if crop.isEmpty || !crop.isFinite { return nil }
        if crop.width <= 1 || crop.height <= 1 { return nil }

        guard let clipped = cg.cropping(to: crop) else { return nil }
        return UIImage(cgImage: clipped, scale: original.scale, orientation: .up)
    }
}

// MARK: - Utils

private extension CGRect {
    static func enclosing(points: [CGPoint]) -> CGRect {
        guard var r = points.first.map({ CGRect(origin: $0, size: .zero) }) else { return .null }
        for p in points.dropFirst() {
            r = r.union(CGRect(origin: p, size: .zero))
        }
        return r
    }

    var isFinite: Bool {
        !(origin.x.isNaN || origin.y.isNaN || size.width.isNaN || size.height.isNaN ||
          origin.x.isInfinite || origin.y.isInfinite || size.width.isInfinite || size.height.isInfinite)
    }
}

private extension CGAffineTransform {
    var isInvertible: Bool { abs(a * d - b * c) > .ulpOfOne }
    var invertedIfPossible: CGAffineTransform? { isInvertible ? inverted() : nil }
}

// MARK: - UIImage orientation normalization

private extension UIImage {
    /// –ü—Ä–∏–≤–æ–¥–∏—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∫ imageOrientation == .up,
    /// –ø—Ä–∏ —ç—Ç–æ–º –≤–∏–∑—É–∞–ª—å–Ω–æ –∫–∞—Ä—Ç–∏–Ω–∫–∞ –æ—Å—Ç–∞—ë—Ç—Å—è —Ç–∞–∫–æ–π –∂–µ, –∫–∞–∫ –µ—ë —Ä–∏—Å—É–µ—Ç UIKit/SwiftUI.
    func normalizedOrientation() -> UIImage {
        if imageOrientation == .up {
            return self
        }

        UIGraphicsBeginImageContextWithOptions(size, false, scale)
        defer { UIGraphicsEndImageContext() }

        draw(in: CGRect(origin: .zero, size: size))
        return UIGraphicsGetImageFromCurrentImageContext() ?? self
    }
}

public enum ContentMode {
    case fit
}


////////////////////////////////////////////////////////////
// FILE: LoadingView.swift
////////////////////////////////////////////////////////////

// Presentation/Scenes/Search/LoadingView.swift
//
//  LoadingView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI
import Swinject

struct LoadingView: View {
    enum Mode { case name, face }

    let mode: Mode
    let previewImage: UIImage?

    /// JPEG-–¥–∞–Ω–Ω—ã–µ –¥–ª—è face-–ø–æ–∏—Å–∫–∞.
    /// –î–ª—è name-–ø–æ–∏—Å–∫–∞ –æ—Å—Ç–∞—ë—Ç—Å—è nil –∏ –ª–æ–≥–∏–∫–∞ –Ω–µ —Ç—Ä–æ–≥–∞–µ–º.
    let imageJPEGData: Data?

    @ObservedObject var vm: SearchViewModel
    let onFinished: () -> Void

    @Environment(\.dismiss) private var dismiss
    @Environment(\.resolver) private var resolver

    @State private var showErrorAlert = false
    @State private var errorMessage: String?

    // Paywall
    @State private var showPaywall: Bool = false

    // –ü–æ–¥–ø–∏—Å–∫–∞
    @State private var isPremiumUser: Bool = true

    // –§–µ–π–∫–æ–≤—ã–π —Å—á—ë—Ç—á–∏–∫ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π (–¥–ª—è face-—Ä–µ–∂–∏–º–∞)
    @State private var matchesCount: Int = 1

    // –ö–æ–Ω—Ç—Ä–æ–ª—å –≤—Ä–µ–º–µ–Ω–∏ —Ñ–µ–π–∫-–ª–æ–∞–¥–µ—Ä–∞
    @State private var minDelayPassed: Bool = false
    @State private var searchCompleted: Bool = false
    @State private var didFinishFlow: Bool = false

    // –°—Ç–∞—Ä—Ç —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ (runImageSearch) —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
    @State private var hasStartedSearch: Bool = false

    // –¢–∞—Å–∫–∏, —á—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –æ—Ç–º–µ–Ω—è—Ç—å
    @State private var fakeCounterTask: Task<Void, Never>?
    @State private var delayTask: Task<Void, Never>?

    // MARK: - Init (—è–≤–Ω—ã–π, —á—Ç–æ–±—ã –Ω–µ –ª–æ–º–∞—Ç—å —Å—Ç–∞—Ä—ã–µ –≤—ã–∑–æ–≤—ã)

    init(
        mode: Mode,
        previewImage: UIImage?,
        imageJPEGData: Data? = nil,
        vm: SearchViewModel,
        onFinished: @escaping () -> Void
    ) {
        self.mode = mode
        self.previewImage = previewImage
        self.imageJPEGData = imageJPEGData
        self.vm = vm
        self.onFinished = onFinished
    }

    // MARK: - Body

    var body: some View {
        ZStack {
            Tokens.Color.backgroundMain.ignoresSafeArea()

            VStack(spacing: 0) {
                // Header
                HStack {
                    BackButton(size: 44.scale) { dismiss() }
                        .disabled(vm.isLoading)
                        .opacity(vm.isLoading ? 0.5 : 1)
                    Spacer()
                    Text("Search by photo")
                        .font(Tokens.Font.bodyMedium18)
                        .foregroundStyle(Tokens.Color.textPrimary)
                    Spacer()
                    Color.clear.frame(width: 44.scale, height: 44.scale)
                }
                .padding(.horizontal, 16.scale)
                .padding(.top, 0.scale)

                Spacer(minLength: 0)

                if mode == .face, let ui = previewImage {
                    VStack(spacing: 16.scale) {
                        Image(uiImage: ui)
                            .resizable()
                            .scaledToFit()
                            .clipShape(RoundedRectangle(cornerRadius: 16.scale, style: .continuous))
                            .shadow(color: Color.black.opacity(0.15), radius: 10)
                            .frame(maxWidth: .infinity)
                            .padding(16.scale)

                        Text("Photo analysis")
                            .font(Tokens.Font.medium20)
                            .foregroundStyle(Tokens.Color.textPrimary)

                        VStack(spacing: 12.scale) {
                            // Matches found in databases 24
                            HStack(spacing: 4.scale) {
                                Text("Matches found in databases")
                                    .font(Tokens.Font.captionRegular)
                                    .foregroundStyle(Tokens.Color.textSecondary)

                                Text("\(matchesCount)")
                                    .font(Tokens.Font.captionRegular)
                                    .foregroundStyle(Tokens.Color.accent)
                            }

                            ThreeDotsLoader()
                        }
                        .padding(.top, 8.scale)
                        .padding(.bottom, 52.scale)
                    }
                } else {
                    VStack(spacing: 16.scale) {
                        ThreeDotsLoader()
                        Text("Searching...")
                            .font(Tokens.Font.body)
                            .foregroundStyle(Tokens.Color.textPrimary)
                    }
                }

                Spacer(minLength: 0)
            }
        }
        .navigationBarBackButtonHidden(true)
        // ‚¨áÔ∏è –ø–æ–∫–∞ —ç—Ç–æ—Ç —ç–∫—Ä–∞–Ω –≤ —Å—Ç–µ–∫–µ ‚Äî –ø—Ä—è—á–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–π —Ç–∞–±–±–∞—Ä
        .toolbar(.hidden, for: .tabBar)

        // Paywall –ø–æ—Å–ª–µ —Ñ–µ–π–∫-–ª–æ–∞–¥–µ—Ä–∞ –¥–ª—è –Ω–µ-–ø—Ä–µ–º–∏—É–º
        .fullScreenCover(isPresented: $showPaywall, onDismiss: {
            handlePaywallDismiss()
        }) {
            let payVM = resolver.resolve(PaywallViewModel.self)!
            PaywallView(vm: payVM)
                .ignoresSafeArea()
        }

        // MARK: - –ñ–∏–∑–Ω–µ–Ω–Ω—ã–π —Ü–∏–∫–ª
        .onAppear {
            setupFlow()
        }
        .onDisappear {
            cancelTasks()
        }

        // MARK: - –†–µ–∞–∫—Ü–∏—è –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏
        .onChange(of: vm.isLoading) { _, isNowLoading in
            guard !didFinishFlow else { return }

            if isNowLoading == false {
                if let msg = vm.errorText, !msg.isEmpty {
                    errorMessage = msg
                    showErrorAlert = true
                    cancelTasks()
                } else {
                    // –£—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç —Å–µ—Ä–≤–µ—Ä–∞
                    searchCompleted = true
                    completeIfReady()
                }
            }
        }
        .onChange(of: vm.errorText) { _, msg in
            guard let msg, !msg.isEmpty else { return }
            errorMessage = msg
            showErrorAlert = true
            cancelTasks()
        }
        .alert("Search failed", isPresented: $showErrorAlert) {
            Button("OK") {
                vm.resetResults()
                dismiss()
            }
        } message: {
            Text(errorMessage ?? "Internal Server Error")
        }
    }
}

// MARK: - –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
private extension LoadingView {
    func setupFlow() {
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –ø—Ä–µ–º–∏—É–º –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞ —Å—Ç–∞—Ä—Ç–µ
        let isPremium = resolver.resolve(PremiumStore.self)?.isPremium ?? false
        isPremiumUser = isPremium

        cancelTasks()
        didFinishFlow = false
        minDelayPassed = false
        searchCompleted = false
        hasStartedSearch = false

        let totalDuration: TimeInterval = isPremium ? 3.0 : 7.0

        // –§–µ–π–∫–æ–≤—ã–π —Å—á—ë—Ç—á–∏–∫ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π (—Ç–æ–ª—å–∫–æ –¥–ª—è face-—Ä–µ–∂–∏–º–∞)
        if mode == .face {
            fakeCounterTask = Task { @MainActor in
                let steps = [1, 3, 8, 11]
                matchesCount = steps.first ?? 1
                if steps.count > 1 {
                    let stepDuration = totalDuration / Double(steps.count - 1)
                    for value in steps.dropFirst() {
                        try? await Task.sleep(for: .seconds(stepDuration))
                        if Task.isCancelled { return }
                        matchesCount = value
                    }
                }
            }
        }

        // –ì–ª–∞–≤–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
        delayTask = Task { @MainActor in
            try? await Task.sleep(for: .seconds(totalDuration))
            if Task.isCancelled { return }

            // 3 –∏–ª–∏ 7 —Å–µ–∫—É–Ω–¥ –ø—Ä–æ—à–ª–∏
            minDelayPassed = true

            if isPremium {
                // –ü—Ä–µ–º–∏—É–º ‚Äî –ø–æ—Å–ª–µ –∑–∞–¥–µ—Ä–∂–∫–∏ –∂–¥—ë–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏ –∏–¥—ë–º –¥–∞–ª—å—à–µ
                completeIfReady()
            } else {
                // –ù–µ –ø—Ä–µ–º–∏—É–º ‚Äî –ø–æ—Å–ª–µ 7 —Å–µ–∫—É–Ω–¥ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º paywall
                showPaywall = true
            }
        }

        // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –ø—Ä–µ–º–∏—É–º ‚Äî —Å—Ä–∞–∑—É —Å—Ç–∞—Ä—Ç—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫
        if isPremium {
            startSearchIfNeeded()
        }
    }

    /// –°—Ç–∞—Ä—Ç—É–µ–º —Ä–µ–∞–ª—å–Ω—ã–π image-–ø–æ–∏—Å–∫ (runImageSearch) —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑
    /// –∏ —Ç–æ–ª—å–∫–æ –¥–ª—è face-—Ä–µ–∂–∏–º–∞.
    func startSearchIfNeeded() {
        guard !hasStartedSearch else { return }
        guard mode == .face, let jpeg = imageJPEGData else { return }

        hasStartedSearch = true

        vm.resetResults()
        vm.runImageSearch(jpegData: jpeg)
    }

    /// –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–æ–≥–¥–∞:
    /// - –∑–∞–∫–æ–Ω—á–∏–ª—Å—è –∑–∞–ø—Ä–æ—Å (vm.isLoading == false –∏ –±–µ–∑ –æ—à–∏–±–∫–∏)
    /// - –ø—Ä–æ—à–ª–æ –º–∏–Ω–∏–º—É–º 3/7 —Å–µ–∫—É–Ω–¥
    /// - –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø—Ä–µ–º–∏—É–º (–∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –∏–ª–∏ –ø–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏ –Ω–∞ Paywall)
    func completeIfReady() {
        guard isPremiumUser else { return }
        guard !didFinishFlow else { return }
        guard minDelayPassed && searchCompleted else { return }

        didFinishFlow = true
        cancelTasks()

        // –ù–µ–±–æ–ª—å—à–∞—è –ø–ª–∞–≤–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ—Ö–æ–¥–æ–º
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            onFinished()
        }
    }

    /// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è Paywall:
    /// - –µ—Å–ª–∏ –ø–æ–¥–ø–∏—Å–∫—É –Ω–µ –∫—É–ø–∏–ª–∏ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ FaceSearchView
    /// - –µ—Å–ª–∏ –∫—É–ø–∏–ª–∏ ‚Äî –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –ø—Ä–µ–º–∏—É–º-–≤–µ—Ç–∫—É –∏ –∏–¥—ë–º –∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º
    ///   (–∏ —Ç–æ–ª—å–∫–æ –¢–ï–ü–ï–†–¨ –¥–µ–ª–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ –±—ç–∫)
    func handlePaywallDismiss() {
        let premiumNow = resolver.resolve(PremiumStore.self)?.isPremium ?? false

        if premiumNow {
            // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ—Ñ–æ—Ä–º–∏–ª –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ Paywall
            isPremiumUser = true

            // 7 —Å–µ–∫—É–Ω–¥ —É–∂–µ –ø—Ä–æ—à–ª–∏, –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ:
            minDelayPassed = true

            // –¢–æ–ª—å–∫–æ —Ç–µ–ø–µ—Ä—å –Ω–∞–ø—Ä—è–≥–∞–µ–º —Å–µ—Ä–≤–µ—Ä
            startSearchIfNeeded()

            // –ï—Å–ª–∏ –ø–æ–∏—Å–∫ —É–∂–µ —É—Å–ø–µ–ª –∑–∞–∫–æ–Ω—á–∏—Ç—å—Å—è ‚Äî —Å—Ä–∞–∑—É –ø–æ–π–¥—ë–º –¥–∞–ª—å—à–µ,
            // –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî –¥–æ–∂–¥—ë–º—Å—è vm.isLoading == false
            completeIfReady()
        } else {
            // –ü–æ–¥–ø–∏—Å–∫—É –Ω–µ –∫—É–ø–∏–ª–∏ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –Ω–∞–∑–∞–¥ –∫ FaceSearchView
            didFinishFlow = true
            cancelTasks()
            dismiss()
        }
    }

    func cancelTasks() {
        fakeCounterTask?.cancel()
        delayTask?.cancel()
        fakeCounterTask = nil
        delayTask = nil
    }
}

// MARK: - –¢—Ä–∏ —Ç–æ—á–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏ (–∫–∞–∫ –Ω–∞ —Å–ø–ª—ç—à–µ)

// ‚¨áÔ∏è –£–ë–†–ê–õ private, —á—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏ –≤ Cheater
struct ThreeDotsLoader: View {
    @State private var activeIndex: Int = 0

    private let big: CGFloat = 16
    private let mid: CGFloat = 8
    private let small: CGFloat = 4
    private let count: Int = 3

    // —à–∞–≥ –∞–Ω–∏–º–∞—Ü–∏–∏
    private let timer = Timer.publish(every: 0.35, on: .main, in: .common).autoconnect()

    var body: some View {
        HStack(spacing: 8.scale) {
            ForEach(0..<count, id: \.self) { idx in
                // —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ —Ç–æ—á–∫–∏ –æ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π (0 ‚Äî –±–æ–ª—å—à–∞—è, 1 ‚Äî —Å—Ä–µ–¥–Ω—è—è, 2 ‚Äî –º–∞–ª–µ–Ω—å–∫–∞—è)
                let dist = (idx - activeIndex + count) % count

                let baseSize: CGFloat =
                    dist == 0 ? big :
                    dist == 1 ? mid :
                    small

                Circle()
                    .fill(
                        dist == 0
                        ? Tokens.Color.accent
                        : Tokens.Color.borderNeutral.opacity(0.35)
                    )
                    .frame(
                        width: baseSize.scale,
                        height: baseSize.scale
                    )
                    .animation(.easeOut(duration: 0.35), value: activeIndex)
            }
        }
        .onReceive(timer) { _ in
            activeIndex = (activeIndex + 1) % count
        }
    }
}


////////////////////////////////////////////////////////////
// FILE: SearchResultsView.swift
////////////////////////////////////////////////////////////

// Presentation/Scenes/Search/SearchResultsView.swift
// CheaterBuster
//
// Created by Niiaz Khasanov on 10/28/25.
//

import SwiftUI
import UIKit
import WebKit

// MARK: - Web sheet item

private struct SearchResultWebItem: Identifiable, Equatable {
    let id = UUID()
    let url: URL
}

struct SearchResultsView: View {
    @ObservedObject var vm: SearchViewModel
    @Binding var path: [SearchScreen.Route]
    
    @State private var didSignalRateUs = false

    // –í–º–µ—Å—Ç–æ Bool + URL ‚Äî –æ–¥–∏–Ω item –¥–ª—è .sheet(item:)
    @State private var activeWebItem: SearchResultWebItem?
    
    // –ñ—ë—Å—Ç–∫–∏–µ —Ä–∞–∑–º–µ—Ä—ã –∏ –æ—Ç—Å—Ç—É–ø—ã
    private let itemSide: CGFloat = 167.5.scale
    private let gridSpacing: CGFloat = Tokens.Spacing.x16
    private let gridPadding: CGFloat = Tokens.Spacing.x16
    private let corner: CGFloat = Tokens.Radius.medium
    
    private var columns: [GridItem] {
        [
            GridItem(.fixed(itemSide), spacing: gridSpacing, alignment: .top),
            GridItem(.fixed(itemSide), spacing: gridSpacing, alignment: .top)
        ]
    }
    
    private var results: [ImageHit] { vm.results }
    
    var body: some View {
        ZStack {
            VStack(spacing: 0) {
                // Header
                HStack {
                    BackButton(size: 44.scale) { _ = path.popLast() }
                    
                    Spacer()
                    
                    Text("Face results")
                        .font(Tokens.Font.bodyMedium18)
                        .foregroundStyle(Tokens.Color.textPrimary)
                    
                    Spacer()
                    Color.clear.frame(width: 44.scale, height: 44.scale)
                }
                .padding(.horizontal, gridPadding)
                .padding(.top, 0.scale)
                .padding(.bottom, Tokens.Spacing.x8)
                
                ScrollView {
                    if results.isEmpty {
                        ContentUnavailableView(
                            "No results found",
                            systemImage: "magnifyingglass.circle",
                            description: Text("No matches found. Please try a different photo.")
                        )
                        .padding(.top, Tokens.Spacing.x24)
                    } else {
                        LazyVGrid(columns: columns, spacing: gridSpacing) {
                            ForEach(results) { hit in
                                SquareResultCell(
                                    hit: hit,
                                    side: itemSide,
                                    corner: corner
                                )
                                .onTapGesture {
                                    handleTap(on: hit)
                                }
                                .onLongPressGesture {
                                    handleTap(on: hit)
                                }
                            }
                        }
                        .padding(.horizontal, gridPadding)
                        .padding(.vertical, Tokens.Spacing.x24)
                        .animation(.easeInOut(duration: 0.25), value: results.count)
                    }
                }
                .background(Tokens.Color.backgroundMain.ignoresSafeArea())
            }
        }
        .navigationBarBackButtonHidden(true)
        .onAppear {
            guard !vm.results.isEmpty, !didSignalRateUs else { return }
            didSignalRateUs = true
            Task { await RateUsScheduler.shared.request(.searchResults) }
        }
        // MARK: - Web sheet —á–µ—Ä–µ–∑ item
        .sheet(item: $activeWebItem) { item in
            SearchResultWebSheet(
                url: item.url,
                onClose: { activeWebItem = nil }
            )
            .ignoresSafeArea()
        }
    }
    
    // MARK: - Actions
    
    private func handleTap(on hit: ImageHit) {
        // –ï—Å–ª–∏ –Ω–µ—Ç —Å—Å—ã–ª–∫–∏ ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
        guard let url = hit.linkURL else { return }
        
        // üîπ ANALYTICS: –ø–æ–ø—ã—Ç–∫–∞ –æ—Ç–∫—Ä—ã—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ WebView
        Analytics.shared.track("search_results_open_webview")
        
        // –û—Ç–∫—Ä—ã–≤–∞–µ–º —Å—Å—ã–ª–∫—É –≤ WebView –≤–Ω—É—Ç—Ä–∏ sheet
        activeWebItem = SearchResultWebItem(url: url)
    }
}

// MARK: - –ö–≤–∞–¥—Ä–∞—Ç–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞

private struct SquareResultCell: View {
    let hit: ImageHit
    let side: CGFloat
    let corner: CGFloat
    
    var body: some View {
        VStack(spacing: Tokens.Spacing.x8) {
            AsyncThumb(url: hit.thumbnailURL)
                .frame(width: side, height: side)
                .clipShape(RoundedRectangle(cornerRadius: corner, style: .continuous))
            
            Text(hit.title)
                .font(Tokens.Font.caption)
                .foregroundStyle(Tokens.Color.textPrimary)
                .lineLimit(1)
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        .frame(width: side)
    }
}

// MARK: - AsyncThumb ‚Äî –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–µ–≤—å—é

private struct AsyncThumb: View {
    let url: URL?
    
    var body: some View {
        AsyncImage(url: url, transaction: .init(animation: .default)) { phase in
            switch phase {
            case .empty:
                Placeholder()
            case .success(let image):
                image
                    .resizable()
                    .scaledToFill()
                    .clipped()
            case .failure:
                Placeholder()
            @unknown default:
                Placeholder()
            }
        }
    }
}

// MARK: - Placeholder

private struct Placeholder: View {
    var body: some View {
        ZStack {
            Tokens.Color.surfaceCard
            Image(systemName: "photo")
                .font(.system(size: 24.scale, weight: .regular))
                .foregroundStyle(Tokens.Color.textSecondary.opacity(0.5))
        }
        .aspectRatio(1, contentMode: .fill)
    }
}

// MARK: - Web sheet –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Å —Ö–µ–¥–µ—Ä–æ–º

private struct SearchResultWebSheet: View {
    let url: URL
    let onClose: () -> Void
    
    @State private var isLoading: Bool = true
    
    var body: some View {
        VStack(spacing: 0) {
            header
            Divider()
                .background(Tokens.Color.borderNeutral.opacity(0.4))
            
            ZStack {
                SearchResultWebView(url: url, isLoading: $isLoading)
                    .id(url) // üîÅ –ø–µ—Ä–µ—Å–æ–∑–¥–∞—ë–º WKWebView –ø—Ä–∏ —Å–º–µ–Ω–µ URL
                    .edgesIgnoringSafeArea(.bottom)
                
                if isLoading {
                    ZStack {
                        Tokens.Color.backgroundMain
                            .opacity(0.3)
                            .ignoresSafeArea()
                        ProgressView()
                            .progressViewStyle(.circular)
                            .scaleEffect(1.2)
                    }
                }
            }
        }
        .background(Tokens.Color.backgroundMain)
    }
    
    private var header: some View {
        HStack(spacing: 12.scale) {
            Button(action: onClose) {
                Text("Close")
                    .font(Tokens.Font.bodyMedium16)
                    .foregroundStyle(Tokens.Color.textPrimary)
            }
            
            // URL –ø–æ —Ü–µ–Ω—Ç—Ä—É, –æ–¥–Ω–∞ —Å—Ç—Ä–æ–∫–∞, —Å –º–Ω–æ–≥–æ—Ç–æ—á–∏–µ–º
            Text(url.absoluteString)
                .font(Tokens.Font.medium12)
                .foregroundStyle(Tokens.Color.textSecondary)
                .lineLimit(1)
                .truncationMode(.middle)
            
            Spacer(minLength: 0)
        }
        .padding(.horizontal, 16.scale)
        .padding(.vertical, 12.scale)
        .background(Color.white)
        .shadow(color: Color.black.opacity(0.08), radius: 6.scale, y: 2.scale)
    }
}

// MARK: - –ß–∏—Å—Ç—ã–π WKWebView —Å –¥–µ–ª–µ–≥–∞—Ç–æ–º –∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–º

private struct SearchResultWebView: UIViewRepresentable {
    let url: URL
    @Binding var isLoading: Bool
    
    // MARK: - Coordinator
    
    final class Coordinator: NSObject, WKNavigationDelegate {
        var parent: SearchResultWebView
        
        init(parent: SearchResultWebView) {
            self.parent = parent
        }
        
        func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
            parent.isLoading = true
            print("üåç [WebView] didStartProvisionalNavigation: \(webView.url?.absoluteString ?? "nil")")
        }
        
        func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
            parent.isLoading = false
            print("‚úÖ [WebView] didFinish: \(webView.url?.absoluteString ?? "nil")")
        }
        
        func webView(_ webView: WKWebView,
                     didFailProvisionalNavigation navigation: WKNavigation!,
                     withError error: Error) {
            parent.isLoading = false
            print("‚ùå [WebView] didFailProvisionalNavigation: \(error.localizedDescription)")
        }
        
        func webView(_ webView: WKWebView,
                     didFail navigation: WKNavigation!,
                     withError error: Error) {
            parent.isLoading = false
            print("‚ùå [WebView] didFail: \(error.localizedDescription)")
        }
        
        // –ï—Å–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å WebKit —É–ø–∞–ª ‚Äî –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º, —á—Ç–æ–±—ã –Ω–µ –≤–∏—Å–µ—Ç—å –Ω–∞ –±–µ–ª–æ–º —ç–∫—Ä–∞–Ω–µ
        func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
            print("‚ö†Ô∏è [WebView] webViewWebContentProcessDidTerminate, reloading‚Ä¶")
            parent.isLoading = true
            webView.reload()
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }
    
    // MARK: - UIViewRepresentable
    
    func makeUIView(context: Context) -> WKWebView {
        let config = WKWebViewConfiguration()
        let web = WKWebView(frame: .zero, configuration: config)
        
        web.navigationDelegate = context.coordinator
        web.scrollView.bounces = true
        web.allowsBackForwardNavigationGestures = true
        
        // –ß—É—Ç—å —É–º–µ–Ω—å—à–∞–µ–º —à–∞–Ω—Å "–≤–µ—á–Ω–æ–≥–æ –±–µ–ª–æ–≥–æ" –∏–∑-–∑–∞ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤
        web.isOpaque = false
        web.backgroundColor = .systemBackground
        
        let request = URLRequest(
            url: url,
            cachePolicy: .reloadIgnoringLocalCacheData,
            timeoutInterval: 30
        )
        web.load(request)
        
        return web
    }
    
    func updateUIView(_ uiView: WKWebView, context: Context) {
        uiView.navigationDelegate = context.coordinator
        
        // –ï—Å–ª–∏ URL –∏–∑–º–µ–Ω–∏–ª—Å—è ‚Äî –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å
        if uiView.url != url {
            let request = URLRequest(
                url: url,
                cachePolicy: .reloadIgnoringLocalCacheData,
                timeoutInterval: 30
            )
            uiView.load(request)
        }
    }
}


////////////////////////////////////////////////////////////
// FILE: SearchScreen.swift
////////////////////////////////////////////////////////////

// Presentation/Search/SearchScreen.swift

import SwiftUI
import Swinject
import PhotosUI
import UniformTypeIdentifiers
import UIKit

// MARK: - Environment key –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ñ–æ—Ç–æ –≤ FaceSearchView

private struct SelectedFaceImageKey: EnvironmentKey {
    static let defaultValue: UIImage? = nil
}

extension EnvironmentValues {
    var selectedFaceImage: UIImage? {
        get { self[SelectedFaceImageKey.self] }
        set { self[SelectedFaceImageKey.self] = newValue }
    }
}

struct SearchScreen: View {
    // MARK: - –ù–∞–≤–∏–≥–∞—Ü–∏—è —á–µ—Ä–µ–∑ path
    enum Route: Hashable {
        case face
        case results
    }

    @State private var path: [Route] = []

    @StateObject private var vm: SearchViewModel

    /// –ö–æ–ª–ª–±–µ–∫ –∑–∞–∫—Ä—ã—Ç–∏—è –≤—Å–µ–≥–æ Search-—Ñ–ª–æ—É (–¥–∏–∑–º–∏—Å—Å —Å Home)
    private let onClose: () -> Void

    // MARK: - Source picker (–∫–∞–∫ –≤ CheaterView)

    @State private var showSourceSheet = false

    // PhotosPicker
    @State private var photoItem: PhotosPickerItem?
    @State private var showPhotoPicker = false

    // Document picker (—Ç–æ–ª—å–∫–æ –∫–∞—Ä—Ç–∏–Ω–∫–∏)
    @State private var showFilePicker = false

    // –í—ã–±—Ä–∞–Ω–Ω–∞—è –∫–∞—Ä—Ç–∏–Ω–∫–∞ (–∏–∑ –≥–∞–ª–µ—Ä–µ–∏ –∏–ª–∏ —Ñ–∞–π–ª–æ–≤)
    @State private var selectedImage: UIImage? = nil

    // MARK: - Init

    init(vm: SearchViewModel, onClose: @escaping () -> Void = {}) {
        _vm = StateObject(wrappedValue: vm)
        self.onClose = onClose
    }

    var body: some View {
        NavigationStack(path: $path) {

            // üëâ –§–∏–∫—Å ¬´–ø—Ä—ã–∂–∫–∞¬ª: –±–µ—Ä—ë–º —Å–∏—Å—Ç–µ–º–Ω—ã–π safeArea bottom (home-indicator),
            // –∞ —Ç–∞–±–±–∞—Ä –±—É–¥–µ–º –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å.
            let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene
            let window = windowScene?.windows.first(where: { $0.isKeyWindow })
            let safeBottomInset = window?.safeAreaInsets.bottom ?? 0

            VStack(spacing: 24.scale) {

                // ==== –ö–ê–°–¢–û–ú–ù–´–ô HEADER ====
                header

                // ==== –ö–∞—Ä—Ç–æ—á–∫–∞ Upload photo ====
                Button {
                    withAnimation(.easeInOut(duration: 0.25)) {
                        showSourceSheet = true
                    }
                } label: {
                    UploadPhotoCardView()
                }
                .buttonStyle(OpacityTapButtonStyle())
                .frame(maxWidth: .infinity, alignment: .center)

                Spacer(minLength: 0)

                // ==== –ö–Ω–æ–ø–∫–∞ Start search ====
                startSearchButton
            }
            .padding(.horizontal, Tokens.Spacing.x16)
            .padding(.top, Tokens.Spacing.x8)
            // –Ω–∏–∂–Ω–∏–π –æ—Ç—Å—Ç—É–ø —Å—á–∏—Ç–∞–µ–º —Å–∞–º–∏: home-indicator + 24pt
            .padding(.bottom, safeBottomInset + 24.scale)
            .background(Tokens.Color.backgroundMain.ignoresSafeArea())
            // –∫–æ–Ω—Ç–µ–Ω—Ç –Ω–µ —Ä–µ–∞–≥–∏—Ä—É–µ—Ç –Ω–∞ –∏–∑–º–µ–Ω–µ–Ω–∏–µ safeArea –∏–∑-–∑–∞ —Ç–∞–±–±–∞—Ä–∞
            .ignoresSafeArea(edges: .bottom)

            // MARK: - –ù–∞–∑–Ω–∞—á–µ–Ω–∏—è
            .navigationDestination(for: Route.self) { route in
                switch route {
                case .face:
                    FaceSearchView(vm: vm, onFinished: { path.append(.results) })
                        .navigationBarBackButtonHidden(true)
                        .edgeSwipeToPop(isEnabled: true) { path.removeLast() }
                        // ‚Üê —Å—é–¥–∞ –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É
                        .environment(\.selectedFaceImage, selectedImage)

                case .results:
                    SearchResultsView(vm: vm, path: $path)
                        .navigationBarBackButtonHidden(true)
                        .edgeSwipeToPop(isEnabled: true) { path.removeLast() }
                }
            }

            // ============================
            //           PICKERS
            // ============================

            // –§–æ—Ç–æ –∏–∑ –≥–∞–ª–µ—Ä–µ–∏
            .photosPicker(
                isPresented: $showPhotoPicker,
                selection: $photoItem,
                matching: .images
            )
            .onChange(of: photoItem) { _, item in
                guard let item else { return }

                Task {
                    if let data = try? await item.loadTransferable(type: Data.self),
                       let img = UIImage(data: data) {
                        await MainActor.run {
                            selectedImage = img
                            navigateToFaceIfNeeded()
                        }
                    }
                    await MainActor.run {
                        photoItem = nil
                    }
                }
            }

            // –§–∞–π–ª, –Ω–æ —Ç–æ–ª—å–∫–æ –∫–∞—Ä—Ç–∏–Ω–∫–∞
            .fileImporter(
                isPresented: $showFilePicker,
                allowedContentTypes: [.image],      // ‚Üê —Å—Ç—Ä–æ–≥–æ —Ç–æ–ª—å–∫–æ –∫–∞—Ä—Ç–∏–Ω–∫–∏
                allowsMultipleSelection: false
            ) { result in
                switch result {
                case .success(let urls):
                    guard let url = urls.first else { return }
                    let secured = url.startAccessingSecurityScopedResource()
                    defer { if secured { url.stopAccessingSecurityScopedResource() } }

                    do {
                        let data = try Data(contentsOf: url)
                        if let img = UIImage(data: data) {
                            selectedImage = img
                            navigateToFaceIfNeeded()
                        }
                    } catch {
                        print("Failed to read image file: \(error.localizedDescription)")
                    }

                case .failure(let error):
                    print("File import failed: \(error.localizedDescription)")
                }
            }

            // === Overlay –≤—ã–±–æ—Ä–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ (Select a photo or file) ===
            .overlay(alignment: .bottom) {
                if showSourceSheet {
                    SourcePickerOverlay(
                        onFiles: {
                            showSourceSheet = false
                            showFilePicker  = true
                        },
                        onLibrary: {
                            showSourceSheet = false
                            showPhotoPicker = true
                        },
                        onDismiss: {
                            showSourceSheet = false
                        }
                    )
                    .zIndex(1000)
                    .ignoresSafeArea()
                }
            }
        }
        // –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä—è—á–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–π navbar
        .navigationBarBackButtonHidden(true)
        .toolbar(.hidden, for: .navigationBar)

        // MARK: - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–∞–±–±–∞—Ä–æ–º (–æ—Å—Ç–∞–≤–ª—è–µ–º, –Ω–µ –º–µ—à–∞–µ—Ç)
        .onChange(of: path) { _, newPath in
            let shouldHideTabBar = !newPath.isEmpty
            TabBarTransparencyAnimator.setTransparent(shouldHideTabBar)
        }
        .onAppear {
            TabBarTransparencyAnimator.setTransparent(false)
        }
        .onDisappear {
            TabBarTransparencyAnimator.setTransparent(false)
        }
    }

    // MARK: - –•–µ–ª–ø–µ—Ä –Ω–∞–≤–∏–≥–∞—Ü–∏–∏

    private func navigateToFaceIfNeeded() {
        if !path.contains(.face) {
            path.append(.face)
        }
    }

    // MARK: - –ö–∞—Å—Ç–æ–º–Ω—ã–π —Ö–µ–¥–µ—Ä

    private var header: some View {
        ZStack {
            // –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
            Text("Search by photo")
                .font(Tokens.Font.medium18)
                .foregroundStyle(Tokens.Color.textPrimary)

            // –õ–µ–≤–∞—è –∫–Ω–æ–ø–∫–∞ Back
            HStack {
                Button {
                    onClose()
                } label: {
                    Image("backButton")
                        .resizable()
                        .renderingMode(.template)
                        .scaledToFit()
                        .frame(width: 24.scale, height: 24.scale)
                }
                .foregroundStyle(Tokens.Color.textPrimary)

                Spacer()
            }
        }
        .padding(.top, 4.scale)
    }

    // MARK: - –ö–Ω–æ–ø–∫–∞ Start search

    private var startSearchButton: some View {
        let hasImage = (selectedImage != nil)

        return Button {
            if hasImage {
                navigateToFaceIfNeeded()
            } else {
                // –ï—Å–ª–∏ —Ñ–æ—Ç–æ –µ—â—ë –Ω–µ—Ç ‚Äî –æ—Ç–∫—Ä—ã–≤–∞–µ–º –≤—ã–±–æ—Ä –∏—Å—Ç–æ—á–Ω–∏–∫–∞
                withAnimation(.easeInOut(duration: 0.25)) {
                    showSourceSheet = true
                }
            }
        } label: {
            HStack(spacing: 8.scale) {
                Text("Start search")
                    .font(Tokens.Font.bodySemibold16)
                    .tracking(-0.16)

                Spacer()

                Image("nextArrow")
                    .resizable()
                    .renderingMode(.template)
                    .scaledToFit()
                    .frame(width: 20.scale, height: 20.scale)
            }
            .foregroundColor(.white)
            .padding(.leading, 20.scale)
            .padding(.trailing, 24.scale)
            .frame(width: 343.scale, height: 51.scale, alignment: .center)
            .background(
                Tokens.Color.accent.opacity(hasImage ? 1.0 : 0.5) // –∞–∫—Ç–∏–≤–Ω–∞—è / –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞—è
            )
            .clipShape(
                RoundedRectangle(
                    cornerRadius: Tokens.Radius.pill,
                    style: .continuous
                )
            )
        }
        .buttonStyle(OpacityTapButtonStyle())
        .frame(maxWidth: .infinity, alignment: .center)
    }
}

// MARK: - –ö–∞—Ä—Ç–æ—á–∫–∞ Upload photo

private struct UploadPhotoCardView: View {
    var body: some View {
        ZStack {
            RoundedRectangle(cornerRadius: 24.scale, style: .continuous)
                .fill(Tokens.Color.accent.opacity(0.08)) // Accent 8%

            VStack(spacing: 12.scale) {
                Image("search.imageIcom")
                    .resizable()
                    .renderingMode(.template)
                    .scaledToFit()
                    .frame(width: 32.scale, height: 32.scale)
                    .foregroundStyle(Tokens.Color.accent)

                Text("Upload a photo")
                    .font(Tokens.Font.bodySemibold16)
                    .foregroundStyle(Tokens.Color.accent)
            }
        }
        .frame(width: 343.scale, height: 200.scale)
    }
}


////////////////////////////////////////////////////////////
// FILE: SearchViewModel.swift
////////////////////////////////////////////////////////////

//
//  SearchViewModel.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 10/28/25.
//

import Foundation
import Combine
import UIKit


final class SearchViewModel: ObservableObject {

    // MARK: - Output
    @Published var results: [ImageHit] = [] 
    @Published private(set) var isLoading: Bool = false            // –º–µ–ª–∫–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã (–≤ –∫–Ω–æ–ø–∫–∞—Ö)
    @Published private(set) var isBlockingLoading: Bool = false     // full-screen –∑–∞–≥—Ä—É–∑–∫–∞
    @Published private(set) var errorText: String?

    // MARK: - Deps
    private let search: SearchService
    private let history: HistoryStore
    private let settings: SettingsStore?

    private var bag = Set<AnyCancellable>()

    // MARK: - Init
    init(search: SearchService,
         history: HistoryStore,
         settings: SettingsStore? = nil)
    {
        self.search = search
        self.history = history
        self.settings = settings
        // NOTE: —É–¥–∞–ª—ë–Ω –¥–µ–±–∞—É–Ω—Å –ø–æ query (name-search)
    }

    // MARK: - –ó–∞–ø—É—Å–∫ –ø–æ –∫–Ω–æ–ø–∫–µ ¬´Analyze¬ª (–ø–æ —Ñ–æ—Ç–æ)

    func runImageSearch(jpegData: Data) {
        // üîª –æ—Ç–º–µ–Ω—è–µ–º –ª—é–±–æ–π –ø—Ä–µ–¥—ã–¥—É—â–∏–π –ø–∞–π–ø–ª–∞–π–Ω
        bag.forEach { $0.cancel() }
        bag.removeAll()

        isLoading = true
        isBlockingLoading = true
        errorText = nil

        search.searchByImage(jpegData)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self else { return }
                self.isLoading = false
                self.isBlockingLoading = false
                if case .failure(let err) = completion {
                    self.errorText = err.localizedDescription
                    self.results = []
                }
            } receiveValue: { [weak self] hits in
                guard let self else { return }
                self.results = hits

                let thumbData = (UIImage(data: jpegData)?
                    .jpegData(compressionQuality: 0.5)) ?? jpegData

                let rec = HistoryRecord(
                    kind: .face,
                    query: nil,
                    imageJPEG: thumbData,
                    titlePreview: hits.first?.title,
                    sourcePreview: hits.first?.source
                )
                self.history.add(rec)
            }
            .store(in: &bag)
    }


    // MARK: - –ü—Ä–æ—á–µ–µ (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å)
    func resetResults() {
        results = []
        errorText = nil
    }
}


////////////////////////////////////////////////////////////
// FILE: Tmp/CropOverlayView.swift
////////////////////////////////////////////////////////////

//
//  CropOverlayView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 11/2/25.
//


//
//  CropOverlayView.swift
//  CheaterBuster
//
//  Created by Niiaz Khasanov on 11/02/25.
//

import SwiftUI

struct CropOverlayView: View {
    let cropRect: CGRect
    let lineWidth: CGFloat

    var body: some View {
        GeometryReader { geo in
            ZStack {
                // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –º–∞—Å–∫–∞ —Å "–¥—ã—Ä–∫–æ–π"
                Path { path in
                    path.addRect(CGRect(origin: .zero, size: geo.size))
                    path.addRect(cropRect)
                }
                .fill(Color.black.opacity(0.5), style: FillStyle(eoFill: true))

                // –†–∞–º–∫–∞
                RoundedRectangle(cornerRadius: 0)
                    .stroke(Tokens.Color.accent, lineWidth: lineWidth)
                    .frame(width: cropRect.width, height: cropRect.height)
                    .position(x: cropRect.midX, y: cropRect.midY)
            }
        }
        .allowsHitTesting(false)
    }
}


